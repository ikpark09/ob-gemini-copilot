import { App, Editor, MarkdownView, Modal, Notice, Plugin, Setting, TFile, Menu } from 'obsidian';\nimport { GoogleGenerativeAI } from \"@google/generative-ai\";\nimport { RelatedDocumentsModal, KnowledgeGraphSummaryModal, GeminiConfirmationModal, CustomPromptSelectorModal } from './modals';\nimport { GeminiCopilotSettingTab } from './settings-tab';\n\nexport interface GeminiCopilotSettings {\n    geminiApiKey: string;\n    geminiModel: string;\n    logHistory: GeminiLogEntry[];\n    defaultNewFileLocation: string;\n    customPrompts: CustomPrompt[];\n    knowledgeGraphSettings: {\n        enabled: boolean;\n        minSimilarityScore: number;\n        maxLinksPerDocument: number;\n        autoAddLinks: boolean;\n    };\n    promptTemplates: {\n        generateTitle: string;\n        summarizeText: string;\n        expandText: string;\n        generateHashtags: string;\n        extractCoreConcepts: string;\n        analyzeDocumentRelation: string;\n    };\n}\n\nexport interface GeminiLogEntry {\n    timestamp: string;\n    model: string;\n    inputPrompt: string;\n    outputResponse: string | null;\n    inputTokens?: number;\n    outputTokens?: number;\n    error?: string;\n}\n\nexport interface CustomPrompt {\n    name: string;\n    prompt: string;\n    description: string;\n}\n\n// 문서 관계 인터페이스 정의\nexport interface DocumentRelation {\n    sourceFile: TFile;\n    targetFile: TFile;\n    similarityScore: number;\n    extractedContext: string;\n}\n\n// Obsidian의 App 인터페이스 확장\ndeclare module 'obsidian' {\n    interface App {\n        plugins: {\n            plugins: {\n                [id: string]: unknown;\n            };\n        };\n        commands: {\n            executeCommandById(id: string): boolean;\n        };\n        setting: {\n            open(): void;\n            openTabById(id: string): void;\n        };\n    }\n}\n\nexport const DEFAULT_SETTINGS: GeminiCopilotSettings = {\n    geminiApiKey: '',\n    geminiModel: 'gemini-pro',\n    logHistory: [],\n    defaultNewFileLocation: 'root',\n    customPrompts: [],\n    knowledgeGraphSettings: {\n        enabled: false,\n        minSimilarityScore: 0.5,\n        maxLinksPerDocument: 5,\n        autoAddLinks: false,\n    },\n    promptTemplates: {\n        generateTitle: 'Generate a concise and informative title for the following note content:{{currentTitle}}\\\\n\\\\n{{content}}\\\\n\\\\nOutput format: YYYY-MM-DD: title. Ensure the title part is suitable for filename (no special chars).',\n        summarizeText: 'Please summarize the following text concisely:\\\\n\\\\n{{content}}\\\\n\\\\nSummary:',\n        expandText: 'Please expand upon the following text, adding more detail and information:\\\\n\\\\n{{content}}\\\\n\\\\nExpanded Text:',\n        generateHashtags: '한글로 다음 문서의 핵심을 나타내는 키워드를 10개 정도 추출하여 설명, 부호, 순서 없이 \\\\'#\\\\'로 시작하는 키워드로 출력하세요.\\\\n문서: \\\\n{{content}}\\\\n\\\\n해시태그: #',\n        extractCoreConcepts: '다음 문서에서 핵심 개념, 주제, 키워드를 5-10개 정도 추출해 주세요. JSON 형식으로 반환하되, 키워드는 단어나 짧은 구문으로 제한해주세요.\\\\n\\\\n문서:\\\\n{{content}}\\\\n\\\\n출력 형식:\\\\n{\\\\n    \\\"concepts\\\": [\\\"개념1\\\", \\\"개념2\\\", \\\"개념3\\\", ...]\\\\n}',\n        analyzeDocumentRelation: '두 문서 간의 관계를 분석하고 유사도 점수(0.0 ~ 1.0 사이)를 매겨주세요.\\\\n\\\\n문서 1: \\\"{{sourceTitle}}\\\"\\\\n핵심 개념: {{sourceConcepts}}\\\\n\\\\n문서 2: \\\"{{targetTitle}}\\\"\\\\n핵심 개념: {{targetConcepts}}\\\\n\\\\n다음 형식으로 JSON으로 응답해주세요:\\\\n{\\\\n    \\\"similarityScore\\\": 0.0부터 1.0 사이의 숫자,\\\\n    \\\"context\\\": \\\"두 문서가 어떻게 관련되어 있는지에 대한 간략한 설명(1-2문장)\\\"\\\\n}'\n    },\n};\n\nexport default class GeminiCopilotPlugin extends Plugin {\n    settings: GeminiCopilotSettings;\n    private genAI: GoogleGenerativeAI | null = null;\n\n    async onload() {\n        await this.loadSettings();\n        this.initializeGeminiAPI();\n\n        this.addRibbonIcon('sparkles', 'Gemini Copilot', (evt: MouseEvent) => {\n            // 메뉴 생성 및 표시\n            const menu = new Menu();\n            \n            // 노트 제목 생성 기능\n            menu.addItem((item) => {\n                item.setTitle('노트 제목 생성')\n                    .setIcon('heading')\n                    .onClick(async () => {\n                        const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);\n                        if (activeView) {\n                            const content = activeView.editor.getValue();\n                            if (!content) {\n                                new Notice('노트 내용이 비어있습니다.');\n                                return;\n                            }\n\n                            try {\n                                const suggestedTitle = await this.generateNoteTitle(content, activeView.file?.basename);\n                                if (!suggestedTitle) {\n                                    new Notice('제목 생성에 실패했습니다.');\n                                    return;\n                                }\n\n                                new GeminiConfirmationModal(this.app, suggestedTitle, async (confirmedTitle) => {\n                                    if (!confirmedTitle) return; // 사용자가 취소함\n\n                                    let newFileName = this.sanitizeFilename(confirmedTitle.trim());\n                                    const creationDate = new Date().toISOString().slice(0, 10);\n                                    const finalFileName = `${creationDate} - ${newFileName}`;\n\n                                    if (activeView.file) {\n                                        // 기존 파일 이름 변경\n                                        const originalFilePath = activeView.file.path;\n                                        const dirPath = activeView.file.parent ? activeView.file.parent.path : \"\";\n                                        const newFilePath = dirPath ? `${dirPath}/${finalFileName}.${activeView.file.extension}` : `${finalFileName}.${activeView.file.extension}`;\n\n                                        try {\n                                            await this.app.fileManager.renameFile(activeView.file, newFilePath);\n                                            new Notice(`노트 제목이 다음으로 변경되었습니다: ${finalFileName}`);\n                                        } catch (error) {\n                                            console.error('파일 이름 변경 오류:', error);\n                                            new Notice(`파일 이름 변경 오류: ${error instanceof Error ? error.message : String(error)}`);\n                                        }\n                                    } else {\n                                        // 신규 파일 생성\n                                        this.createNewFileWithTitle(content, finalFileName);\n                                    }\n                                }).open();\n\n                            } catch (error) {\n                                console.error('노트 제목 생성 오류:', error);\n                                new Notice('노트 제목 생성 중 오류가 발생했습니다.');\n                            }\n                        } else {\n                            new Notice('노트가 열려있지 않습니다.');\n                        }\n                    });\n            });\n            \n            // 메뉴의 나머지 항목 추가 (생략)...\n            \n            // 메뉴 표시\n            menu.showAtMouseEvent(evt);\n        });\n\n        // 명령어 추가\n        this.addCommands();\n\n        this.addSettingTab(new GeminiCopilotSettingTab(this.app, this));\n    }\n\n    // 명령어 추가 메서드\n    private addCommands() {\n        // 제목 생성 명령어\n        this.addCommand({\n            id: 'gemini-generate-note-title',\n            name: 'Generate Note Title with Gemini',\n            editorCallback: async (editor: Editor, view: MarkdownView) => {\n                // 내용 생략..\n            }\n        });\n\n        // 텍스트 요약 명령어\n        this.addCommand({\n            id: 'gemini-summarize-text',\n            name: 'Summarize Selected Text with Gemini',\n            editorCallback: async (editor: Editor, view: MarkdownView) => {\n                // 내용 생략..\n            }\n        });\n\n        // 기타 명령어들...\n    }\n\n    onunload() {\n        this.genAI = null;\n    }\n\n    async loadSettings() {\n        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());\n    }\n\n    async saveSettings() {\n        await this.saveData(this.settings);\n        this.initializeGeminiAPI();\n    }\n\n    private initializeGeminiAPI() {\n        if (this.settings.geminiApiKey) {\n            this.genAI = new GoogleGenerativeAI(this.settings.geminiApiKey);\n        } else {\n            this.genAI = null;\n            console.warn('Gemini API Key is not set. Plugin features will be disabled.');\n        }\n    }\n\n    private async generateContent(prompt: string): Promise<{ text: string | null }> {\n        if (!this.genAI) {\n            new Notice('Gemini API Key is not configured.');\n            return { text: null };\n        }\n\n        let responseText: string | null = null;\n        let logEntry: GeminiLogEntry = {\n            timestamp: new Date().toISOString(),\n            model: this.settings.geminiModel,\n            inputPrompt: prompt,\n            outputResponse: null,\n            inputTokens: undefined,\n            outputTokens: undefined,\n            error: undefined\n        };\n\n        try {\n            const model = this.genAI.getGenerativeModel({ model: this.settings.geminiModel });\n            const result = await model.generateContent(prompt);\n            responseText = result.response.text();\n            logEntry.outputResponse = responseText;\n            this.logGeminiInteraction(logEntry);\n            return { text: responseText };\n\n        } catch (error) {\n            console.error('Gemini API Error:', error);\n            logEntry.error = error instanceof Error ? error.message : String(error);\n            this.logGeminiInteraction(logEntry);\n            new Notice('Gemini API call failed. See console for details.');\n            return { text: null };\n        }\n    }\n\n    private logGeminiInteraction(logEntry: GeminiLogEntry) {\n        this.settings.logHistory.push(logEntry);\n        this.saveSettings();\n        console.log(\"Gemini Interaction Logged:\", logEntry);\n    }\n\n    sanitizeFilename(filename: string): string {\n        const invalidCharsRegex = /[*\"\\\\\\/<>:|?]/g;\n        return filename.replace(invalidCharsRegex, '_');\n    }\n\n    async generateNoteTitle(content: string, currentTitle: string | undefined): Promise<string | null> {\n        let prompt = this.settings.promptTemplates.generateTitle;\n        \n        // 변수 교체\n        prompt = prompt.replace('{{content}}', content);\n        prompt = prompt.replace('{{currentTitle}}', currentTitle ? ` using current title: ${currentTitle}` : '');\n        \n        const response = await this.generateContent(prompt);\n        return response.text;\n    }\n\n    async summarizeText(text: string): Promise<string | null> {\n        let prompt = this.settings.promptTemplates.summarizeText;\n        \n        // 변수 교체\n        prompt = prompt.replace('{{content}}', text);\n        \n        const response = await this.generateContent(prompt);\n        return response.text;\n    }\n\n    async generateAdditionalText(text: string): Promise<string | null> {\n        let prompt = this.settings.promptTemplates.expandText;\n        \n        // 변수 교체\n        prompt = prompt.replace('{{content}}', text);\n        \n        const response = await this.generateContent(prompt);\n        return response.text;\n    }\n\n    async generateHashtags(text: string): Promise<string | null> {\n        let prompt = this.settings.promptTemplates.generateHashtags;\n        \n        // 변수 교체\n        prompt = prompt.replace('{{content}}', text);\n        \n        const response = await this.generateContent(prompt);\n        return response.text;\n    }\n\n    // 지식 그래프 생성 메서드\n    async generateKnowledgeGraph(): Promise<void> {\n        const markdownFiles = this.app.vault.getMarkdownFiles();\n        \n        if (markdownFiles.length === 0) {\n            new Notice('분석할 마크다운 파일이 없습니다.');\n            return;\n        }\n\n        const totalFiles = markdownFiles.length;\n        let processedFiles = 0;\n        const relations: DocumentRelation[] = [];\n\n        // 각 파일을 처리\n        for (const sourceFile of markdownFiles) {\n            try {\n                const sourceContent = await this.app.vault.read(sourceFile);\n                if (!sourceContent.trim()) continue; // 빈 파일 건너뛰기\n\n                // 관련 문서 찾기\n                const relatedDocs = await this.findRelatedDocuments(sourceFile, sourceContent);\n                relations.push(...relatedDocs);\n\n                // 진행 상황 업데이트\n                processedFiles++;\n                if (processedFiles % 10 === 0 || processedFiles === totalFiles) {\n                    new Notice(`지식 그래프 분석 중: ${processedFiles}/${totalFiles} 파일 처리됨`);\n                }\n            } catch (error) {\n                console.error(`파일 ${sourceFile.path} 처리 중 오류 발생:`, error);\n            }\n        }\n\n        // 자동으로 링크 추가하기 (설정에서 활성화된 경우)\n        if (this.settings.knowledgeGraphSettings.autoAddLinks) {\n            await this.addWikiLinksToDocuments(relations);\n        }\n\n        new Notice(`지식 그래프 생성 완료: 총 ${relations.length}개의 관계 발견`);\n        \n        // 분석 결과 요약 표시\n        new KnowledgeGraphSummaryModal(this.app, relations).open();\n    }\n\n    // 관련 문서 찾기\n    async findRelatedDocuments(sourceFile: TFile, sourceContent: string): Promise<DocumentRelation[]> {\n        const markdownFiles = this.app.vault.getMarkdownFiles();\n        const relations: DocumentRelation[] = [];\n        \n        // 소스 파일 자신은 제외\n        const otherFiles = markdownFiles.filter(file => file.path !== sourceFile.path);\n        \n        // 소스 문서의 핵심 개념 추출\n        const sourceConcepts = await this.extractCoreConcepts(sourceContent);\n        if (!sourceConcepts) return relations;\n\n        // 각 파일과 비교\n        for (const targetFile of otherFiles) {\n            try {\n                const targetContent = await this.app.vault.read(targetFile);\n                if (!targetContent.trim()) continue; // 빈 파일 건너뛰기\n\n                // 타겟 문서의 핵심 개념 추출\n                const targetConcepts = await this.extractCoreConcepts(targetContent);\n                if (!targetConcepts) continue;\n\n                // 두 문서 간의 관계 분석\n                const analysisResult = await this.analyzeDocumentRelation(\n                    sourceFile.basename, \n                    sourceConcepts,\n                    targetFile.basename, \n                    targetConcepts\n                );\n\n                if (analysisResult && \n                    analysisResult.similarityScore >= this.settings.knowledgeGraphSettings.minSimilarityScore) {\n                    relations.push({\n                        sourceFile: sourceFile,\n                        targetFile: targetFile,\n                        similarityScore: analysisResult.similarityScore,\n                        extractedContext: analysisResult.context\n                    });\n                }\n            } catch (error) {\n                console.error(`파일 ${targetFile.path} 비교 중 오류 발생:`, error);\n            }\n        }\n\n        // 유사도 점수에 따라 정렬\n        relations.sort((a, b) => b.similarityScore - a.similarityScore);\n        \n        // 최대 링크 수 제한\n        return relations.slice(0, this.settings.knowledgeGraphSettings.maxLinksPerDocument);\n    }\n\n    // 문서에서 핵심 개념 추출\n    async extractCoreConcepts(content: string): Promise<string | null> {\n        let prompt = this.settings.promptTemplates.extractCoreConcepts;\n        \n        // 변수 교체\n        prompt = prompt.replace('{{content}}', content.substring(0, 2000) + (content.length > 2000 ? '...(이하 생략)' : ''));\n        \n        const response = await this.generateContent(prompt);\n        if (!response.text) return null;\n\n        try {\n            // JSON 형식 파싱\n            const jsonMatch = response.text.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                const conceptsData = JSON.parse(jsonMatch[0]);\n                return conceptsData.concepts.join(', ');\n            }\n            return response.text;\n        } catch (error) {\n            console.error('핵심 개념 추출 결과 파싱 오류:', error);\n            return response.text; // 파싱 실패 시 원본 텍스트 반환\n        }\n    }\n\n    // 두 문서 간의 관계 분석\n    async analyzeDocumentRelation(\n        sourceTitle: string, \n        sourceConcepts: string,\n        targetTitle: string, \n        targetConcepts: string\n    ): Promise<{ similarityScore: number, context: string } | null> {\n        let prompt = this.settings.promptTemplates.analyzeDocumentRelation;\n        \n        // 변수 교체\n        prompt = prompt.replace('{{sourceTitle}}', sourceTitle);\n        prompt = prompt.replace('{{sourceConcepts}}', sourceConcepts);\n        prompt = prompt.replace('{{targetTitle}}', targetTitle);\n        prompt = prompt.replace('{{targetConcepts}}', targetConcepts);\n\n        const response = await this.generateContent(prompt);\n        if (!response.text) return null;\n\n        try {\n            // JSON 형식 파싱\n            const jsonMatch = response.text.match(/\\{[\\s\\S]*\\}/);\n            if (jsonMatch) {\n                return JSON.parse(jsonMatch[0]);\n            }\n            return null;\n        } catch (error) {\n            console.error('문서 관계 분석 결과 파싱 오류:', error);\n            return null;\n        }\n    }\n\n    // 위키링크 추가\n    async addWikiLinksToDocuments(relations: DocumentRelation[]): Promise<void> {\n        const processedFiles = new Set<string>();\n        \n        for (const relation of relations) {\n            try {\n                // 이미 처리한 파일은 건너뛰기\n                if (processedFiles.has(relation.sourceFile.path)) continue;\n                \n                // 현재 문서 내용 읽기\n                const content = await this.app.vault.read(relation.sourceFile);\n                \n                // 관련 문서들 그룹화\n                const relatedFiles = relations\n                    .filter(r => r.sourceFile.path === relation.sourceFile.path)\n                    .sort((a, b) => b.similarityScore - a.similarityScore)\n                    .slice(0, this.settings.knowledgeGraphSettings.maxLinksPerDocument);\n                \n                if (relatedFiles.length === 0) continue;\n                \n                // 관련 문서 목록 생성\n                let relatedLinksSection = '\\n\\n## 관련 문서\\n';\n                for (const rel of relatedFiles) {\n                    const linkText = `- [[${rel.targetFile.basename}]] - ${rel.extractedContext}\\n`;\n                    relatedLinksSection += linkText;\n                }\n                \n                // 이미 '관련 문서' 섹션이 있는지 확인\n                if (content.includes('## 관련 문서')) {\n                    // 기존 관련 문서 섹션 업데이트는 복잡할 수 있으므로 건너뛰기\n                    continue;\n                }\n                \n                // 새 내용 작성\n                const newContent = content + relatedLinksSection;\n                \n                // 파일 업데이트\n                await this.app.vault.modify(relation.sourceFile, newContent);\n                processedFiles.add(relation.sourceFile.path);\n            } catch (error) {\n                console.error(`파일 ${relation.sourceFile.path}에 링크 추가 중 오류 발생:`, error);\n            }\n        }\n        \n        new Notice(`${processedFiles.size}개 문서에 관련 링크가 추가되었습니다.`);\n    }\n\n    // 새 파일 생성을 위한 헬퍼 메서드 추가\n    private async createNewFileWithTitle(content: string, finalFileName: string): Promise<void> {\n        // 기본 새 파일 위치 설정에서 가져오기\n        let newFilePath = '';\n        if(this.settings.defaultNewFileLocation === 'root') {\n            newFilePath = `${finalFileName}.md`; // 기본값: 볼트 루트, .md 확장자 추가\n        }\n        else if (this.settings.defaultNewFileLocation === 'current') {\n            // 현재 활성화된 파일의 경로 가져오기 시도\n            const activeFile = this.app.workspace.getActiveFile();\n            if (activeFile && activeFile.parent) {\n                const activeDir = activeFile.parent.path; // 활성화된 파일의 디렉토리 경로 가져오기\n                newFilePath = `${activeDir}/${finalFileName}.md`; // 활성화된 노트의 폴더 사용\n            } else {\n                // activeFile이 루트 폴더에 있거나 존재하지 않음\n                newFilePath = `${finalFileName}.md`;\n                new Notice(\"새 노트가 루트 폴더에 생성됩니다.\");\n            }\n        }\n        else if (this.settings.defaultNewFileLocation) { // 특정 폴더가 설정된 경우\n            newFilePath = `${this.settings.defaultNewFileLocation}/${finalFileName}.md`;\n        } else {\n            // 설정이 제대로 되지 않은 경우 기본값으로 루트 사용\n            newFilePath = `${finalFileName}.md`;\n            console.warn(\"잘못된 newFileLocation 설정, 루트 폴더 사용\");\n        }\n\n        console.log(\"새 파일 경로:\", newFilePath);\n\n        try {\n            // 새 파일 생성\n            const newFile = await this.app.vault.create(newFilePath, content);\n            new Notice(`새 노트 생성됨: ${finalFileName}`);\n\n            // 새 파일을 새 창에서 열기\n            await this.app.workspace.getLeaf(true).openFile(newFile);\n        } catch (error) {\n            console.error('새 파일 생성 오류:', error);\n            new Notice(`파일 생성 오류: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n}